// Code generated by mockery. DO NOT EDIT.

package orm

import (
	orm "github.com/goravel/framework/contracts/database/orm"
	mock "github.com/stretchr/testify/mock"
)

// Transaction is an autogenerated mock type for the Transaction type
type Transaction struct {
	mock.Mock
}

type Transaction_Expecter struct {
	mock *mock.Mock
}

func (_m *Transaction) EXPECT() *Transaction_Expecter {
	return &Transaction_Expecter{mock: &_m.Mock}
}

// Association provides a mock function with given fields: association
func (_m *Transaction) Association(association string) orm.Association {
	ret := _m.Called(association)

	if len(ret) == 0 {
		panic("no return value specified for Association")
	}

	var r0 orm.Association
	if rf, ok := ret.Get(0).(func(string) orm.Association); ok {
		r0 = rf(association)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Association)
		}
	}

	return r0
}

// Transaction_Association_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Association'
type Transaction_Association_Call struct {
	*mock.Call
}

// Association is a helper method to define mock.On call
//   - association string
func (_e *Transaction_Expecter) Association(association interface{}) *Transaction_Association_Call {
	return &Transaction_Association_Call{Call: _e.mock.On("Association", association)}
}

func (_c *Transaction_Association_Call) Run(run func(association string)) *Transaction_Association_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Transaction_Association_Call) Return(_a0 orm.Association) *Transaction_Association_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Association_Call) RunAndReturn(run func(string) orm.Association) *Transaction_Association_Call {
	_c.Call.Return(run)
	return _c
}

// Begin provides a mock function with given fields:
func (_m *Transaction) Begin() (orm.Transaction, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Begin")
	}

	var r0 orm.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func() (orm.Transaction, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() orm.Transaction); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Transaction_Begin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Begin'
type Transaction_Begin_Call struct {
	*mock.Call
}

// Begin is a helper method to define mock.On call
func (_e *Transaction_Expecter) Begin() *Transaction_Begin_Call {
	return &Transaction_Begin_Call{Call: _e.mock.On("Begin")}
}

func (_c *Transaction_Begin_Call) Run(run func()) *Transaction_Begin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Transaction_Begin_Call) Return(_a0 orm.Transaction, _a1 error) *Transaction_Begin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Transaction_Begin_Call) RunAndReturn(run func() (orm.Transaction, error)) *Transaction_Begin_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function with given fields:
func (_m *Transaction) Commit() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type Transaction_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
func (_e *Transaction_Expecter) Commit() *Transaction_Commit_Call {
	return &Transaction_Commit_Call{Call: _e.mock.On("Commit")}
}

func (_c *Transaction_Commit_Call) Run(run func()) *Transaction_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Transaction_Commit_Call) Return(_a0 error) *Transaction_Commit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Commit_Call) RunAndReturn(run func() error) *Transaction_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function with given fields: count
func (_m *Transaction) Count(count *int64) error {
	ret := _m.Called(count)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*int64) error); ok {
		r0 = rf(count)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type Transaction_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - count *int64
func (_e *Transaction_Expecter) Count(count interface{}) *Transaction_Count_Call {
	return &Transaction_Count_Call{Call: _e.mock.On("Count", count)}
}

func (_c *Transaction_Count_Call) Run(run func(count *int64)) *Transaction_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*int64))
	})
	return _c
}

func (_c *Transaction_Count_Call) Return(_a0 error) *Transaction_Count_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Count_Call) RunAndReturn(run func(*int64) error) *Transaction_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: value
func (_m *Transaction) Create(value interface{}) error {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type Transaction_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - value interface{}
func (_e *Transaction_Expecter) Create(value interface{}) *Transaction_Create_Call {
	return &Transaction_Create_Call{Call: _e.mock.On("Create", value)}
}

func (_c *Transaction_Create_Call) Run(run func(value interface{})) *Transaction_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Transaction_Create_Call) Return(_a0 error) *Transaction_Create_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Create_Call) RunAndReturn(run func(interface{}) error) *Transaction_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Cursor provides a mock function with given fields:
func (_m *Transaction) Cursor() (chan orm.Cursor, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Cursor")
	}

	var r0 chan orm.Cursor
	var r1 error
	if rf, ok := ret.Get(0).(func() (chan orm.Cursor, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() chan orm.Cursor); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan orm.Cursor)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Transaction_Cursor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Cursor'
type Transaction_Cursor_Call struct {
	*mock.Call
}

// Cursor is a helper method to define mock.On call
func (_e *Transaction_Expecter) Cursor() *Transaction_Cursor_Call {
	return &Transaction_Cursor_Call{Call: _e.mock.On("Cursor")}
}

func (_c *Transaction_Cursor_Call) Run(run func()) *Transaction_Cursor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Transaction_Cursor_Call) Return(_a0 chan orm.Cursor, _a1 error) *Transaction_Cursor_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Transaction_Cursor_Call) RunAndReturn(run func() (chan orm.Cursor, error)) *Transaction_Cursor_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: value, conds
func (_m *Transaction) Delete(value interface{}, conds ...interface{}) (*orm.Result, error) {
	var _ca []interface{}
	_ca = append(_ca, value)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 *orm.Result
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) (*orm.Result, error)); ok {
		return rf(value, conds...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *orm.Result); ok {
		r0 = rf(value, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*orm.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...interface{}) error); ok {
		r1 = rf(value, conds...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Transaction_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type Transaction_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - value interface{}
//   - conds ...interface{}
func (_e *Transaction_Expecter) Delete(value interface{}, conds ...interface{}) *Transaction_Delete_Call {
	return &Transaction_Delete_Call{Call: _e.mock.On("Delete",
		append([]interface{}{value}, conds...)...)}
}

func (_c *Transaction_Delete_Call) Run(run func(value interface{}, conds ...interface{})) *Transaction_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_Delete_Call) Return(_a0 *orm.Result, _a1 error) *Transaction_Delete_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Transaction_Delete_Call) RunAndReturn(run func(interface{}, ...interface{}) (*orm.Result, error)) *Transaction_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// Distinct provides a mock function with given fields: args
func (_m *Transaction) Distinct(args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Distinct")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(...interface{}) orm.Query); ok {
		r0 = rf(args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_Distinct_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Distinct'
type Transaction_Distinct_Call struct {
	*mock.Call
}

// Distinct is a helper method to define mock.On call
//   - args ...interface{}
func (_e *Transaction_Expecter) Distinct(args ...interface{}) *Transaction_Distinct_Call {
	return &Transaction_Distinct_Call{Call: _e.mock.On("Distinct",
		append([]interface{}{}, args...)...)}
}

func (_c *Transaction_Distinct_Call) Run(run func(args ...interface{})) *Transaction_Distinct_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Transaction_Distinct_Call) Return(_a0 orm.Query) *Transaction_Distinct_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Distinct_Call) RunAndReturn(run func(...interface{}) orm.Query) *Transaction_Distinct_Call {
	_c.Call.Return(run)
	return _c
}

// Driver provides a mock function with given fields:
func (_m *Transaction) Driver() orm.Driver {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Driver")
	}

	var r0 orm.Driver
	if rf, ok := ret.Get(0).(func() orm.Driver); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(orm.Driver)
	}

	return r0
}

// Transaction_Driver_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Driver'
type Transaction_Driver_Call struct {
	*mock.Call
}

// Driver is a helper method to define mock.On call
func (_e *Transaction_Expecter) Driver() *Transaction_Driver_Call {
	return &Transaction_Driver_Call{Call: _e.mock.On("Driver")}
}

func (_c *Transaction_Driver_Call) Run(run func()) *Transaction_Driver_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Transaction_Driver_Call) Return(_a0 orm.Driver) *Transaction_Driver_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Driver_Call) RunAndReturn(run func() orm.Driver) *Transaction_Driver_Call {
	_c.Call.Return(run)
	return _c
}

// Exec provides a mock function with given fields: sql, values
func (_m *Transaction) Exec(sql string, values ...interface{}) (*orm.Result, error) {
	var _ca []interface{}
	_ca = append(_ca, sql)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *orm.Result
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...interface{}) (*orm.Result, error)); ok {
		return rf(sql, values...)
	}
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *orm.Result); ok {
		r0 = rf(sql, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*orm.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(sql, values...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Transaction_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type Transaction_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - sql string
//   - values ...interface{}
func (_e *Transaction_Expecter) Exec(sql interface{}, values ...interface{}) *Transaction_Exec_Call {
	return &Transaction_Exec_Call{Call: _e.mock.On("Exec",
		append([]interface{}{sql}, values...)...)}
}

func (_c *Transaction_Exec_Call) Run(run func(sql string, values ...interface{})) *Transaction_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_Exec_Call) Return(_a0 *orm.Result, _a1 error) *Transaction_Exec_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Transaction_Exec_Call) RunAndReturn(run func(string, ...interface{}) (*orm.Result, error)) *Transaction_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function with given fields: exists
func (_m *Transaction) Exists(exists *bool) error {
	ret := _m.Called(exists)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*bool) error); ok {
		r0 = rf(exists)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type Transaction_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - exists *bool
func (_e *Transaction_Expecter) Exists(exists interface{}) *Transaction_Exists_Call {
	return &Transaction_Exists_Call{Call: _e.mock.On("Exists", exists)}
}

func (_c *Transaction_Exists_Call) Run(run func(exists *bool)) *Transaction_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*bool))
	})
	return _c
}

func (_c *Transaction_Exists_Call) Return(_a0 error) *Transaction_Exists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Exists_Call) RunAndReturn(run func(*bool) error) *Transaction_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Find provides a mock function with given fields: dest, conds
func (_m *Transaction) Find(dest interface{}, conds ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Find")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) error); ok {
		r0 = rf(dest, conds...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_Find_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Find'
type Transaction_Find_Call struct {
	*mock.Call
}

// Find is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *Transaction_Expecter) Find(dest interface{}, conds ...interface{}) *Transaction_Find_Call {
	return &Transaction_Find_Call{Call: _e.mock.On("Find",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *Transaction_Find_Call) Run(run func(dest interface{}, conds ...interface{})) *Transaction_Find_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_Find_Call) Return(_a0 error) *Transaction_Find_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Find_Call) RunAndReturn(run func(interface{}, ...interface{}) error) *Transaction_Find_Call {
	_c.Call.Return(run)
	return _c
}

// FindOrFail provides a mock function with given fields: dest, conds
func (_m *Transaction) FindOrFail(dest interface{}, conds ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindOrFail")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) error); ok {
		r0 = rf(dest, conds...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_FindOrFail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindOrFail'
type Transaction_FindOrFail_Call struct {
	*mock.Call
}

// FindOrFail is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *Transaction_Expecter) FindOrFail(dest interface{}, conds ...interface{}) *Transaction_FindOrFail_Call {
	return &Transaction_FindOrFail_Call{Call: _e.mock.On("FindOrFail",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *Transaction_FindOrFail_Call) Run(run func(dest interface{}, conds ...interface{})) *Transaction_FindOrFail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_FindOrFail_Call) Return(_a0 error) *Transaction_FindOrFail_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_FindOrFail_Call) RunAndReturn(run func(interface{}, ...interface{}) error) *Transaction_FindOrFail_Call {
	_c.Call.Return(run)
	return _c
}

// First provides a mock function with given fields: dest
func (_m *Transaction) First(dest interface{}) error {
	ret := _m.Called(dest)

	if len(ret) == 0 {
		panic("no return value specified for First")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_First_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'First'
type Transaction_First_Call struct {
	*mock.Call
}

// First is a helper method to define mock.On call
//   - dest interface{}
func (_e *Transaction_Expecter) First(dest interface{}) *Transaction_First_Call {
	return &Transaction_First_Call{Call: _e.mock.On("First", dest)}
}

func (_c *Transaction_First_Call) Run(run func(dest interface{})) *Transaction_First_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Transaction_First_Call) Return(_a0 error) *Transaction_First_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_First_Call) RunAndReturn(run func(interface{}) error) *Transaction_First_Call {
	_c.Call.Return(run)
	return _c
}

// FirstOr provides a mock function with given fields: dest, callback
func (_m *Transaction) FirstOr(dest interface{}, callback func() error) error {
	ret := _m.Called(dest, callback)

	if len(ret) == 0 {
		panic("no return value specified for FirstOr")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, func() error) error); ok {
		r0 = rf(dest, callback)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_FirstOr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOr'
type Transaction_FirstOr_Call struct {
	*mock.Call
}

// FirstOr is a helper method to define mock.On call
//   - dest interface{}
//   - callback func() error
func (_e *Transaction_Expecter) FirstOr(dest interface{}, callback interface{}) *Transaction_FirstOr_Call {
	return &Transaction_FirstOr_Call{Call: _e.mock.On("FirstOr", dest, callback)}
}

func (_c *Transaction_FirstOr_Call) Run(run func(dest interface{}, callback func() error)) *Transaction_FirstOr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}), args[1].(func() error))
	})
	return _c
}

func (_c *Transaction_FirstOr_Call) Return(_a0 error) *Transaction_FirstOr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_FirstOr_Call) RunAndReturn(run func(interface{}, func() error) error) *Transaction_FirstOr_Call {
	_c.Call.Return(run)
	return _c
}

// FirstOrCreate provides a mock function with given fields: dest, conds
func (_m *Transaction) FirstOrCreate(dest interface{}, conds ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FirstOrCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) error); ok {
		r0 = rf(dest, conds...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_FirstOrCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOrCreate'
type Transaction_FirstOrCreate_Call struct {
	*mock.Call
}

// FirstOrCreate is a helper method to define mock.On call
//   - dest interface{}
//   - conds ...interface{}
func (_e *Transaction_Expecter) FirstOrCreate(dest interface{}, conds ...interface{}) *Transaction_FirstOrCreate_Call {
	return &Transaction_FirstOrCreate_Call{Call: _e.mock.On("FirstOrCreate",
		append([]interface{}{dest}, conds...)...)}
}

func (_c *Transaction_FirstOrCreate_Call) Run(run func(dest interface{}, conds ...interface{})) *Transaction_FirstOrCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_FirstOrCreate_Call) Return(_a0 error) *Transaction_FirstOrCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_FirstOrCreate_Call) RunAndReturn(run func(interface{}, ...interface{}) error) *Transaction_FirstOrCreate_Call {
	_c.Call.Return(run)
	return _c
}

// FirstOrFail provides a mock function with given fields: dest
func (_m *Transaction) FirstOrFail(dest interface{}) error {
	ret := _m.Called(dest)

	if len(ret) == 0 {
		panic("no return value specified for FirstOrFail")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_FirstOrFail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOrFail'
type Transaction_FirstOrFail_Call struct {
	*mock.Call
}

// FirstOrFail is a helper method to define mock.On call
//   - dest interface{}
func (_e *Transaction_Expecter) FirstOrFail(dest interface{}) *Transaction_FirstOrFail_Call {
	return &Transaction_FirstOrFail_Call{Call: _e.mock.On("FirstOrFail", dest)}
}

func (_c *Transaction_FirstOrFail_Call) Run(run func(dest interface{})) *Transaction_FirstOrFail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Transaction_FirstOrFail_Call) Return(_a0 error) *Transaction_FirstOrFail_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_FirstOrFail_Call) RunAndReturn(run func(interface{}) error) *Transaction_FirstOrFail_Call {
	_c.Call.Return(run)
	return _c
}

// FirstOrNew provides a mock function with given fields: dest, attributes, values
func (_m *Transaction) FirstOrNew(dest interface{}, attributes interface{}, values ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, dest, attributes)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FirstOrNew")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...interface{}) error); ok {
		r0 = rf(dest, attributes, values...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_FirstOrNew_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirstOrNew'
type Transaction_FirstOrNew_Call struct {
	*mock.Call
}

// FirstOrNew is a helper method to define mock.On call
//   - dest interface{}
//   - attributes interface{}
//   - values ...interface{}
func (_e *Transaction_Expecter) FirstOrNew(dest interface{}, attributes interface{}, values ...interface{}) *Transaction_FirstOrNew_Call {
	return &Transaction_FirstOrNew_Call{Call: _e.mock.On("FirstOrNew",
		append([]interface{}{dest, attributes}, values...)...)}
}

func (_c *Transaction_FirstOrNew_Call) Run(run func(dest interface{}, attributes interface{}, values ...interface{})) *Transaction_FirstOrNew_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_FirstOrNew_Call) Return(_a0 error) *Transaction_FirstOrNew_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_FirstOrNew_Call) RunAndReturn(run func(interface{}, interface{}, ...interface{}) error) *Transaction_FirstOrNew_Call {
	_c.Call.Return(run)
	return _c
}

// ForceDelete provides a mock function with given fields: value, conds
func (_m *Transaction) ForceDelete(value interface{}, conds ...interface{}) (*orm.Result, error) {
	var _ca []interface{}
	_ca = append(_ca, value)
	_ca = append(_ca, conds...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ForceDelete")
	}

	var r0 *orm.Result
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) (*orm.Result, error)); ok {
		return rf(value, conds...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *orm.Result); ok {
		r0 = rf(value, conds...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*orm.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...interface{}) error); ok {
		r1 = rf(value, conds...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Transaction_ForceDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForceDelete'
type Transaction_ForceDelete_Call struct {
	*mock.Call
}

// ForceDelete is a helper method to define mock.On call
//   - value interface{}
//   - conds ...interface{}
func (_e *Transaction_Expecter) ForceDelete(value interface{}, conds ...interface{}) *Transaction_ForceDelete_Call {
	return &Transaction_ForceDelete_Call{Call: _e.mock.On("ForceDelete",
		append([]interface{}{value}, conds...)...)}
}

func (_c *Transaction_ForceDelete_Call) Run(run func(value interface{}, conds ...interface{})) *Transaction_ForceDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_ForceDelete_Call) Return(_a0 *orm.Result, _a1 error) *Transaction_ForceDelete_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Transaction_ForceDelete_Call) RunAndReturn(run func(interface{}, ...interface{}) (*orm.Result, error)) *Transaction_ForceDelete_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: dest
func (_m *Transaction) Get(dest interface{}) error {
	ret := _m.Called(dest)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Transaction_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - dest interface{}
func (_e *Transaction_Expecter) Get(dest interface{}) *Transaction_Get_Call {
	return &Transaction_Get_Call{Call: _e.mock.On("Get", dest)}
}

func (_c *Transaction_Get_Call) Run(run func(dest interface{})) *Transaction_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Transaction_Get_Call) Return(_a0 error) *Transaction_Get_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Get_Call) RunAndReturn(run func(interface{}) error) *Transaction_Get_Call {
	_c.Call.Return(run)
	return _c
}

// Group provides a mock function with given fields: name
func (_m *Transaction) Group(name string) orm.Query {
	ret := _m.Called(name)

	if len(ret) == 0 {
		panic("no return value specified for Group")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string) orm.Query); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_Group_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Group'
type Transaction_Group_Call struct {
	*mock.Call
}

// Group is a helper method to define mock.On call
//   - name string
func (_e *Transaction_Expecter) Group(name interface{}) *Transaction_Group_Call {
	return &Transaction_Group_Call{Call: _e.mock.On("Group", name)}
}

func (_c *Transaction_Group_Call) Run(run func(name string)) *Transaction_Group_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Transaction_Group_Call) Return(_a0 orm.Query) *Transaction_Group_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Group_Call) RunAndReturn(run func(string) orm.Query) *Transaction_Group_Call {
	_c.Call.Return(run)
	return _c
}

// Having provides a mock function with given fields: query, args
func (_m *Transaction) Having(query interface{}, args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Having")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) orm.Query); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_Having_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Having'
type Transaction_Having_Call struct {
	*mock.Call
}

// Having is a helper method to define mock.On call
//   - query interface{}
//   - args ...interface{}
func (_e *Transaction_Expecter) Having(query interface{}, args ...interface{}) *Transaction_Having_Call {
	return &Transaction_Having_Call{Call: _e.mock.On("Having",
		append([]interface{}{query}, args...)...)}
}

func (_c *Transaction_Having_Call) Run(run func(query interface{}, args ...interface{})) *Transaction_Having_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_Having_Call) Return(_a0 orm.Query) *Transaction_Having_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Having_Call) RunAndReturn(run func(interface{}, ...interface{}) orm.Query) *Transaction_Having_Call {
	_c.Call.Return(run)
	return _c
}

// InRandomOrder provides a mock function with given fields:
func (_m *Transaction) InRandomOrder() orm.Query {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for InRandomOrder")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func() orm.Query); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_InRandomOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InRandomOrder'
type Transaction_InRandomOrder_Call struct {
	*mock.Call
}

// InRandomOrder is a helper method to define mock.On call
func (_e *Transaction_Expecter) InRandomOrder() *Transaction_InRandomOrder_Call {
	return &Transaction_InRandomOrder_Call{Call: _e.mock.On("InRandomOrder")}
}

func (_c *Transaction_InRandomOrder_Call) Run(run func()) *Transaction_InRandomOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Transaction_InRandomOrder_Call) Return(_a0 orm.Query) *Transaction_InRandomOrder_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_InRandomOrder_Call) RunAndReturn(run func() orm.Query) *Transaction_InRandomOrder_Call {
	_c.Call.Return(run)
	return _c
}

// Join provides a mock function with given fields: query, args
func (_m *Transaction) Join(query string, args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Join")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, ...interface{}) orm.Query); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_Join_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Join'
type Transaction_Join_Call struct {
	*mock.Call
}

// Join is a helper method to define mock.On call
//   - query string
//   - args ...interface{}
func (_e *Transaction_Expecter) Join(query interface{}, args ...interface{}) *Transaction_Join_Call {
	return &Transaction_Join_Call{Call: _e.mock.On("Join",
		append([]interface{}{query}, args...)...)}
}

func (_c *Transaction_Join_Call) Run(run func(query string, args ...interface{})) *Transaction_Join_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_Join_Call) Return(_a0 orm.Query) *Transaction_Join_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Join_Call) RunAndReturn(run func(string, ...interface{}) orm.Query) *Transaction_Join_Call {
	_c.Call.Return(run)
	return _c
}

// Limit provides a mock function with given fields: limit
func (_m *Transaction) Limit(limit int) orm.Query {
	ret := _m.Called(limit)

	if len(ret) == 0 {
		panic("no return value specified for Limit")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(int) orm.Query); ok {
		r0 = rf(limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_Limit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Limit'
type Transaction_Limit_Call struct {
	*mock.Call
}

// Limit is a helper method to define mock.On call
//   - limit int
func (_e *Transaction_Expecter) Limit(limit interface{}) *Transaction_Limit_Call {
	return &Transaction_Limit_Call{Call: _e.mock.On("Limit", limit)}
}

func (_c *Transaction_Limit_Call) Run(run func(limit int)) *Transaction_Limit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Transaction_Limit_Call) Return(_a0 orm.Query) *Transaction_Limit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Limit_Call) RunAndReturn(run func(int) orm.Query) *Transaction_Limit_Call {
	_c.Call.Return(run)
	return _c
}

// Load provides a mock function with given fields: dest, relation, args
func (_m *Transaction) Load(dest interface{}, relation string, args ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, dest, relation)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Load")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, string, ...interface{}) error); ok {
		r0 = rf(dest, relation, args...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_Load_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Load'
type Transaction_Load_Call struct {
	*mock.Call
}

// Load is a helper method to define mock.On call
//   - dest interface{}
//   - relation string
//   - args ...interface{}
func (_e *Transaction_Expecter) Load(dest interface{}, relation interface{}, args ...interface{}) *Transaction_Load_Call {
	return &Transaction_Load_Call{Call: _e.mock.On("Load",
		append([]interface{}{dest, relation}, args...)...)}
}

func (_c *Transaction_Load_Call) Run(run func(dest interface{}, relation string, args ...interface{})) *Transaction_Load_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_Load_Call) Return(_a0 error) *Transaction_Load_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Load_Call) RunAndReturn(run func(interface{}, string, ...interface{}) error) *Transaction_Load_Call {
	_c.Call.Return(run)
	return _c
}

// LoadMissing provides a mock function with given fields: dest, relation, args
func (_m *Transaction) LoadMissing(dest interface{}, relation string, args ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, dest, relation)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoadMissing")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, string, ...interface{}) error); ok {
		r0 = rf(dest, relation, args...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_LoadMissing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadMissing'
type Transaction_LoadMissing_Call struct {
	*mock.Call
}

// LoadMissing is a helper method to define mock.On call
//   - dest interface{}
//   - relation string
//   - args ...interface{}
func (_e *Transaction_Expecter) LoadMissing(dest interface{}, relation interface{}, args ...interface{}) *Transaction_LoadMissing_Call {
	return &Transaction_LoadMissing_Call{Call: _e.mock.On("LoadMissing",
		append([]interface{}{dest, relation}, args...)...)}
}

func (_c *Transaction_LoadMissing_Call) Run(run func(dest interface{}, relation string, args ...interface{})) *Transaction_LoadMissing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_LoadMissing_Call) Return(_a0 error) *Transaction_LoadMissing_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_LoadMissing_Call) RunAndReturn(run func(interface{}, string, ...interface{}) error) *Transaction_LoadMissing_Call {
	_c.Call.Return(run)
	return _c
}

// LockForUpdate provides a mock function with given fields:
func (_m *Transaction) LockForUpdate() orm.Query {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LockForUpdate")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func() orm.Query); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_LockForUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LockForUpdate'
type Transaction_LockForUpdate_Call struct {
	*mock.Call
}

// LockForUpdate is a helper method to define mock.On call
func (_e *Transaction_Expecter) LockForUpdate() *Transaction_LockForUpdate_Call {
	return &Transaction_LockForUpdate_Call{Call: _e.mock.On("LockForUpdate")}
}

func (_c *Transaction_LockForUpdate_Call) Run(run func()) *Transaction_LockForUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Transaction_LockForUpdate_Call) Return(_a0 orm.Query) *Transaction_LockForUpdate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_LockForUpdate_Call) RunAndReturn(run func() orm.Query) *Transaction_LockForUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// Model provides a mock function with given fields: value
func (_m *Transaction) Model(value interface{}) orm.Query {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for Model")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(interface{}) orm.Query); ok {
		r0 = rf(value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_Model_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Model'
type Transaction_Model_Call struct {
	*mock.Call
}

// Model is a helper method to define mock.On call
//   - value interface{}
func (_e *Transaction_Expecter) Model(value interface{}) *Transaction_Model_Call {
	return &Transaction_Model_Call{Call: _e.mock.On("Model", value)}
}

func (_c *Transaction_Model_Call) Run(run func(value interface{})) *Transaction_Model_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Transaction_Model_Call) Return(_a0 orm.Query) *Transaction_Model_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Model_Call) RunAndReturn(run func(interface{}) orm.Query) *Transaction_Model_Call {
	_c.Call.Return(run)
	return _c
}

// Offset provides a mock function with given fields: offset
func (_m *Transaction) Offset(offset int) orm.Query {
	ret := _m.Called(offset)

	if len(ret) == 0 {
		panic("no return value specified for Offset")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(int) orm.Query); ok {
		r0 = rf(offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_Offset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Offset'
type Transaction_Offset_Call struct {
	*mock.Call
}

// Offset is a helper method to define mock.On call
//   - offset int
func (_e *Transaction_Expecter) Offset(offset interface{}) *Transaction_Offset_Call {
	return &Transaction_Offset_Call{Call: _e.mock.On("Offset", offset)}
}

func (_c *Transaction_Offset_Call) Run(run func(offset int)) *Transaction_Offset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int))
	})
	return _c
}

func (_c *Transaction_Offset_Call) Return(_a0 orm.Query) *Transaction_Offset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Offset_Call) RunAndReturn(run func(int) orm.Query) *Transaction_Offset_Call {
	_c.Call.Return(run)
	return _c
}

// Omit provides a mock function with given fields: columns
func (_m *Transaction) Omit(columns ...string) orm.Query {
	_va := make([]interface{}, len(columns))
	for _i := range columns {
		_va[_i] = columns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Omit")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(...string) orm.Query); ok {
		r0 = rf(columns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_Omit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Omit'
type Transaction_Omit_Call struct {
	*mock.Call
}

// Omit is a helper method to define mock.On call
//   - columns ...string
func (_e *Transaction_Expecter) Omit(columns ...interface{}) *Transaction_Omit_Call {
	return &Transaction_Omit_Call{Call: _e.mock.On("Omit",
		append([]interface{}{}, columns...)...)}
}

func (_c *Transaction_Omit_Call) Run(run func(columns ...string)) *Transaction_Omit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Transaction_Omit_Call) Return(_a0 orm.Query) *Transaction_Omit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Omit_Call) RunAndReturn(run func(...string) orm.Query) *Transaction_Omit_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhere provides a mock function with given fields: query, args
func (_m *Transaction) OrWhere(query interface{}, args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for OrWhere")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) orm.Query); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_OrWhere_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhere'
type Transaction_OrWhere_Call struct {
	*mock.Call
}

// OrWhere is a helper method to define mock.On call
//   - query interface{}
//   - args ...interface{}
func (_e *Transaction_Expecter) OrWhere(query interface{}, args ...interface{}) *Transaction_OrWhere_Call {
	return &Transaction_OrWhere_Call{Call: _e.mock.On("OrWhere",
		append([]interface{}{query}, args...)...)}
}

func (_c *Transaction_OrWhere_Call) Run(run func(query interface{}, args ...interface{})) *Transaction_OrWhere_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_OrWhere_Call) Return(_a0 orm.Query) *Transaction_OrWhere_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_OrWhere_Call) RunAndReturn(run func(interface{}, ...interface{}) orm.Query) *Transaction_OrWhere_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhereBetween provides a mock function with given fields: column, x, y
func (_m *Transaction) OrWhereBetween(column string, x interface{}, y interface{}) orm.Query {
	ret := _m.Called(column, x, y)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereBetween")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}) orm.Query); ok {
		r0 = rf(column, x, y)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_OrWhereBetween_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhereBetween'
type Transaction_OrWhereBetween_Call struct {
	*mock.Call
}

// OrWhereBetween is a helper method to define mock.On call
//   - column string
//   - x interface{}
//   - y interface{}
func (_e *Transaction_Expecter) OrWhereBetween(column interface{}, x interface{}, y interface{}) *Transaction_OrWhereBetween_Call {
	return &Transaction_OrWhereBetween_Call{Call: _e.mock.On("OrWhereBetween", column, x, y)}
}

func (_c *Transaction_OrWhereBetween_Call) Run(run func(column string, x interface{}, y interface{})) *Transaction_OrWhereBetween_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(interface{}))
	})
	return _c
}

func (_c *Transaction_OrWhereBetween_Call) Return(_a0 orm.Query) *Transaction_OrWhereBetween_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_OrWhereBetween_Call) RunAndReturn(run func(string, interface{}, interface{}) orm.Query) *Transaction_OrWhereBetween_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhereIn provides a mock function with given fields: column, values
func (_m *Transaction) OrWhereIn(column string, values []interface{}) orm.Query {
	ret := _m.Called(column, values)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereIn")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, []interface{}) orm.Query); ok {
		r0 = rf(column, values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_OrWhereIn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhereIn'
type Transaction_OrWhereIn_Call struct {
	*mock.Call
}

// OrWhereIn is a helper method to define mock.On call
//   - column string
//   - values []interface{}
func (_e *Transaction_Expecter) OrWhereIn(column interface{}, values interface{}) *Transaction_OrWhereIn_Call {
	return &Transaction_OrWhereIn_Call{Call: _e.mock.On("OrWhereIn", column, values)}
}

func (_c *Transaction_OrWhereIn_Call) Run(run func(column string, values []interface{})) *Transaction_OrWhereIn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]interface{}))
	})
	return _c
}

func (_c *Transaction_OrWhereIn_Call) Return(_a0 orm.Query) *Transaction_OrWhereIn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_OrWhereIn_Call) RunAndReturn(run func(string, []interface{}) orm.Query) *Transaction_OrWhereIn_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhereNotBetween provides a mock function with given fields: column, x, y
func (_m *Transaction) OrWhereNotBetween(column string, x interface{}, y interface{}) orm.Query {
	ret := _m.Called(column, x, y)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereNotBetween")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}) orm.Query); ok {
		r0 = rf(column, x, y)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_OrWhereNotBetween_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhereNotBetween'
type Transaction_OrWhereNotBetween_Call struct {
	*mock.Call
}

// OrWhereNotBetween is a helper method to define mock.On call
//   - column string
//   - x interface{}
//   - y interface{}
func (_e *Transaction_Expecter) OrWhereNotBetween(column interface{}, x interface{}, y interface{}) *Transaction_OrWhereNotBetween_Call {
	return &Transaction_OrWhereNotBetween_Call{Call: _e.mock.On("OrWhereNotBetween", column, x, y)}
}

func (_c *Transaction_OrWhereNotBetween_Call) Run(run func(column string, x interface{}, y interface{})) *Transaction_OrWhereNotBetween_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(interface{}))
	})
	return _c
}

func (_c *Transaction_OrWhereNotBetween_Call) Return(_a0 orm.Query) *Transaction_OrWhereNotBetween_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_OrWhereNotBetween_Call) RunAndReturn(run func(string, interface{}, interface{}) orm.Query) *Transaction_OrWhereNotBetween_Call {
	_c.Call.Return(run)
	return _c
}

// OrWhereNotIn provides a mock function with given fields: column, values
func (_m *Transaction) OrWhereNotIn(column string, values []interface{}) orm.Query {
	ret := _m.Called(column, values)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereNotIn")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, []interface{}) orm.Query); ok {
		r0 = rf(column, values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_OrWhereNotIn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrWhereNotIn'
type Transaction_OrWhereNotIn_Call struct {
	*mock.Call
}

// OrWhereNotIn is a helper method to define mock.On call
//   - column string
//   - values []interface{}
func (_e *Transaction_Expecter) OrWhereNotIn(column interface{}, values interface{}) *Transaction_OrWhereNotIn_Call {
	return &Transaction_OrWhereNotIn_Call{Call: _e.mock.On("OrWhereNotIn", column, values)}
}

func (_c *Transaction_OrWhereNotIn_Call) Run(run func(column string, values []interface{})) *Transaction_OrWhereNotIn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]interface{}))
	})
	return _c
}

func (_c *Transaction_OrWhereNotIn_Call) Return(_a0 orm.Query) *Transaction_OrWhereNotIn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_OrWhereNotIn_Call) RunAndReturn(run func(string, []interface{}) orm.Query) *Transaction_OrWhereNotIn_Call {
	_c.Call.Return(run)
	return _c
}

// Order provides a mock function with given fields: value
func (_m *Transaction) Order(value interface{}) orm.Query {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for Order")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(interface{}) orm.Query); ok {
		r0 = rf(value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_Order_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Order'
type Transaction_Order_Call struct {
	*mock.Call
}

// Order is a helper method to define mock.On call
//   - value interface{}
func (_e *Transaction_Expecter) Order(value interface{}) *Transaction_Order_Call {
	return &Transaction_Order_Call{Call: _e.mock.On("Order", value)}
}

func (_c *Transaction_Order_Call) Run(run func(value interface{})) *Transaction_Order_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Transaction_Order_Call) Return(_a0 orm.Query) *Transaction_Order_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Order_Call) RunAndReturn(run func(interface{}) orm.Query) *Transaction_Order_Call {
	_c.Call.Return(run)
	return _c
}

// OrderBy provides a mock function with given fields: column, direction
func (_m *Transaction) OrderBy(column string, direction ...string) orm.Query {
	_va := make([]interface{}, len(direction))
	for _i := range direction {
		_va[_i] = direction[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for OrderBy")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, ...string) orm.Query); ok {
		r0 = rf(column, direction...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_OrderBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrderBy'
type Transaction_OrderBy_Call struct {
	*mock.Call
}

// OrderBy is a helper method to define mock.On call
//   - column string
//   - direction ...string
func (_e *Transaction_Expecter) OrderBy(column interface{}, direction ...interface{}) *Transaction_OrderBy_Call {
	return &Transaction_OrderBy_Call{Call: _e.mock.On("OrderBy",
		append([]interface{}{column}, direction...)...)}
}

func (_c *Transaction_OrderBy_Call) Run(run func(column string, direction ...string)) *Transaction_OrderBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_OrderBy_Call) Return(_a0 orm.Query) *Transaction_OrderBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_OrderBy_Call) RunAndReturn(run func(string, ...string) orm.Query) *Transaction_OrderBy_Call {
	_c.Call.Return(run)
	return _c
}

// OrderByDesc provides a mock function with given fields: column
func (_m *Transaction) OrderByDesc(column string) orm.Query {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for OrderByDesc")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string) orm.Query); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_OrderByDesc_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrderByDesc'
type Transaction_OrderByDesc_Call struct {
	*mock.Call
}

// OrderByDesc is a helper method to define mock.On call
//   - column string
func (_e *Transaction_Expecter) OrderByDesc(column interface{}) *Transaction_OrderByDesc_Call {
	return &Transaction_OrderByDesc_Call{Call: _e.mock.On("OrderByDesc", column)}
}

func (_c *Transaction_OrderByDesc_Call) Run(run func(column string)) *Transaction_OrderByDesc_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Transaction_OrderByDesc_Call) Return(_a0 orm.Query) *Transaction_OrderByDesc_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_OrderByDesc_Call) RunAndReturn(run func(string) orm.Query) *Transaction_OrderByDesc_Call {
	_c.Call.Return(run)
	return _c
}

// Paginate provides a mock function with given fields: page, limit, dest, total
func (_m *Transaction) Paginate(page int, limit int, dest interface{}, total *int64) error {
	ret := _m.Called(page, limit, dest, total)

	if len(ret) == 0 {
		panic("no return value specified for Paginate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, int, interface{}, *int64) error); ok {
		r0 = rf(page, limit, dest, total)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_Paginate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Paginate'
type Transaction_Paginate_Call struct {
	*mock.Call
}

// Paginate is a helper method to define mock.On call
//   - page int
//   - limit int
//   - dest interface{}
//   - total *int64
func (_e *Transaction_Expecter) Paginate(page interface{}, limit interface{}, dest interface{}, total interface{}) *Transaction_Paginate_Call {
	return &Transaction_Paginate_Call{Call: _e.mock.On("Paginate", page, limit, dest, total)}
}

func (_c *Transaction_Paginate_Call) Run(run func(page int, limit int, dest interface{}, total *int64)) *Transaction_Paginate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(int), args[2].(interface{}), args[3].(*int64))
	})
	return _c
}

func (_c *Transaction_Paginate_Call) Return(_a0 error) *Transaction_Paginate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Paginate_Call) RunAndReturn(run func(int, int, interface{}, *int64) error) *Transaction_Paginate_Call {
	_c.Call.Return(run)
	return _c
}

// Pluck provides a mock function with given fields: column, dest
func (_m *Transaction) Pluck(column string, dest interface{}) error {
	ret := _m.Called(column, dest)

	if len(ret) == 0 {
		panic("no return value specified for Pluck")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(column, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_Pluck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pluck'
type Transaction_Pluck_Call struct {
	*mock.Call
}

// Pluck is a helper method to define mock.On call
//   - column string
//   - dest interface{}
func (_e *Transaction_Expecter) Pluck(column interface{}, dest interface{}) *Transaction_Pluck_Call {
	return &Transaction_Pluck_Call{Call: _e.mock.On("Pluck", column, dest)}
}

func (_c *Transaction_Pluck_Call) Run(run func(column string, dest interface{})) *Transaction_Pluck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *Transaction_Pluck_Call) Return(_a0 error) *Transaction_Pluck_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Pluck_Call) RunAndReturn(run func(string, interface{}) error) *Transaction_Pluck_Call {
	_c.Call.Return(run)
	return _c
}

// Raw provides a mock function with given fields: sql, values
func (_m *Transaction) Raw(sql string, values ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, sql)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Raw")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, ...interface{}) orm.Query); ok {
		r0 = rf(sql, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_Raw_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Raw'
type Transaction_Raw_Call struct {
	*mock.Call
}

// Raw is a helper method to define mock.On call
//   - sql string
//   - values ...interface{}
func (_e *Transaction_Expecter) Raw(sql interface{}, values ...interface{}) *Transaction_Raw_Call {
	return &Transaction_Raw_Call{Call: _e.mock.On("Raw",
		append([]interface{}{sql}, values...)...)}
}

func (_c *Transaction_Raw_Call) Run(run func(sql string, values ...interface{})) *Transaction_Raw_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_Raw_Call) Return(_a0 orm.Query) *Transaction_Raw_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Raw_Call) RunAndReturn(run func(string, ...interface{}) orm.Query) *Transaction_Raw_Call {
	_c.Call.Return(run)
	return _c
}

// Rollback provides a mock function with given fields:
func (_m *Transaction) Rollback() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Rollback")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_Rollback_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rollback'
type Transaction_Rollback_Call struct {
	*mock.Call
}

// Rollback is a helper method to define mock.On call
func (_e *Transaction_Expecter) Rollback() *Transaction_Rollback_Call {
	return &Transaction_Rollback_Call{Call: _e.mock.On("Rollback")}
}

func (_c *Transaction_Rollback_Call) Run(run func()) *Transaction_Rollback_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Transaction_Rollback_Call) Return(_a0 error) *Transaction_Rollback_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Rollback_Call) RunAndReturn(run func() error) *Transaction_Rollback_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields: value
func (_m *Transaction) Save(value interface{}) error {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type Transaction_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - value interface{}
func (_e *Transaction_Expecter) Save(value interface{}) *Transaction_Save_Call {
	return &Transaction_Save_Call{Call: _e.mock.On("Save", value)}
}

func (_c *Transaction_Save_Call) Run(run func(value interface{})) *Transaction_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Transaction_Save_Call) Return(_a0 error) *Transaction_Save_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Save_Call) RunAndReturn(run func(interface{}) error) *Transaction_Save_Call {
	_c.Call.Return(run)
	return _c
}

// SaveQuietly provides a mock function with given fields: value
func (_m *Transaction) SaveQuietly(value interface{}) error {
	ret := _m.Called(value)

	if len(ret) == 0 {
		panic("no return value specified for SaveQuietly")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_SaveQuietly_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveQuietly'
type Transaction_SaveQuietly_Call struct {
	*mock.Call
}

// SaveQuietly is a helper method to define mock.On call
//   - value interface{}
func (_e *Transaction_Expecter) SaveQuietly(value interface{}) *Transaction_SaveQuietly_Call {
	return &Transaction_SaveQuietly_Call{Call: _e.mock.On("SaveQuietly", value)}
}

func (_c *Transaction_SaveQuietly_Call) Run(run func(value interface{})) *Transaction_SaveQuietly_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Transaction_SaveQuietly_Call) Return(_a0 error) *Transaction_SaveQuietly_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_SaveQuietly_Call) RunAndReturn(run func(interface{}) error) *Transaction_SaveQuietly_Call {
	_c.Call.Return(run)
	return _c
}

// Scan provides a mock function with given fields: dest
func (_m *Transaction) Scan(dest interface{}) error {
	ret := _m.Called(dest)

	if len(ret) == 0 {
		panic("no return value specified for Scan")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}) error); ok {
		r0 = rf(dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_Scan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Scan'
type Transaction_Scan_Call struct {
	*mock.Call
}

// Scan is a helper method to define mock.On call
//   - dest interface{}
func (_e *Transaction_Expecter) Scan(dest interface{}) *Transaction_Scan_Call {
	return &Transaction_Scan_Call{Call: _e.mock.On("Scan", dest)}
}

func (_c *Transaction_Scan_Call) Run(run func(dest interface{})) *Transaction_Scan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}))
	})
	return _c
}

func (_c *Transaction_Scan_Call) Return(_a0 error) *Transaction_Scan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Scan_Call) RunAndReturn(run func(interface{}) error) *Transaction_Scan_Call {
	_c.Call.Return(run)
	return _c
}

// Scopes provides a mock function with given fields: funcs
func (_m *Transaction) Scopes(funcs ...func(orm.Query) orm.Query) orm.Query {
	_va := make([]interface{}, len(funcs))
	for _i := range funcs {
		_va[_i] = funcs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Scopes")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(...func(orm.Query) orm.Query) orm.Query); ok {
		r0 = rf(funcs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_Scopes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Scopes'
type Transaction_Scopes_Call struct {
	*mock.Call
}

// Scopes is a helper method to define mock.On call
//   - funcs ...func(orm.Query) orm.Query
func (_e *Transaction_Expecter) Scopes(funcs ...interface{}) *Transaction_Scopes_Call {
	return &Transaction_Scopes_Call{Call: _e.mock.On("Scopes",
		append([]interface{}{}, funcs...)...)}
}

func (_c *Transaction_Scopes_Call) Run(run func(funcs ...func(orm.Query) orm.Query)) *Transaction_Scopes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(orm.Query) orm.Query, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(func(orm.Query) orm.Query)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *Transaction_Scopes_Call) Return(_a0 orm.Query) *Transaction_Scopes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Scopes_Call) RunAndReturn(run func(...func(orm.Query) orm.Query) orm.Query) *Transaction_Scopes_Call {
	_c.Call.Return(run)
	return _c
}

// Select provides a mock function with given fields: query, args
func (_m *Transaction) Select(query interface{}, args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Select")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) orm.Query); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_Select_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Select'
type Transaction_Select_Call struct {
	*mock.Call
}

// Select is a helper method to define mock.On call
//   - query interface{}
//   - args ...interface{}
func (_e *Transaction_Expecter) Select(query interface{}, args ...interface{}) *Transaction_Select_Call {
	return &Transaction_Select_Call{Call: _e.mock.On("Select",
		append([]interface{}{query}, args...)...)}
}

func (_c *Transaction_Select_Call) Run(run func(query interface{}, args ...interface{})) *Transaction_Select_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_Select_Call) Return(_a0 orm.Query) *Transaction_Select_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Select_Call) RunAndReturn(run func(interface{}, ...interface{}) orm.Query) *Transaction_Select_Call {
	_c.Call.Return(run)
	return _c
}

// SharedLock provides a mock function with given fields:
func (_m *Transaction) SharedLock() orm.Query {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SharedLock")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func() orm.Query); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_SharedLock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SharedLock'
type Transaction_SharedLock_Call struct {
	*mock.Call
}

// SharedLock is a helper method to define mock.On call
func (_e *Transaction_Expecter) SharedLock() *Transaction_SharedLock_Call {
	return &Transaction_SharedLock_Call{Call: _e.mock.On("SharedLock")}
}

func (_c *Transaction_SharedLock_Call) Run(run func()) *Transaction_SharedLock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Transaction_SharedLock_Call) Return(_a0 orm.Query) *Transaction_SharedLock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_SharedLock_Call) RunAndReturn(run func() orm.Query) *Transaction_SharedLock_Call {
	_c.Call.Return(run)
	return _c
}

// Sum provides a mock function with given fields: column, dest
func (_m *Transaction) Sum(column string, dest interface{}) error {
	ret := _m.Called(column, dest)

	if len(ret) == 0 {
		panic("no return value specified for Sum")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(column, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_Sum_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sum'
type Transaction_Sum_Call struct {
	*mock.Call
}

// Sum is a helper method to define mock.On call
//   - column string
//   - dest interface{}
func (_e *Transaction_Expecter) Sum(column interface{}, dest interface{}) *Transaction_Sum_Call {
	return &Transaction_Sum_Call{Call: _e.mock.On("Sum", column, dest)}
}

func (_c *Transaction_Sum_Call) Run(run func(column string, dest interface{})) *Transaction_Sum_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}))
	})
	return _c
}

func (_c *Transaction_Sum_Call) Return(_a0 error) *Transaction_Sum_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Sum_Call) RunAndReturn(run func(string, interface{}) error) *Transaction_Sum_Call {
	_c.Call.Return(run)
	return _c
}

// Table provides a mock function with given fields: name, args
func (_m *Transaction) Table(name string, args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, name)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Table")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, ...interface{}) orm.Query); ok {
		r0 = rf(name, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_Table_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Table'
type Transaction_Table_Call struct {
	*mock.Call
}

// Table is a helper method to define mock.On call
//   - name string
//   - args ...interface{}
func (_e *Transaction_Expecter) Table(name interface{}, args ...interface{}) *Transaction_Table_Call {
	return &Transaction_Table_Call{Call: _e.mock.On("Table",
		append([]interface{}{name}, args...)...)}
}

func (_c *Transaction_Table_Call) Run(run func(name string, args ...interface{})) *Transaction_Table_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_Table_Call) Return(_a0 orm.Query) *Transaction_Table_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Table_Call) RunAndReturn(run func(string, ...interface{}) orm.Query) *Transaction_Table_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: column, value
func (_m *Transaction) Update(column interface{}, value ...interface{}) (*orm.Result, error) {
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, value...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *orm.Result
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) (*orm.Result, error)); ok {
		return rf(column, value...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) *orm.Result); ok {
		r0 = rf(column, value...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*orm.Result)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...interface{}) error); ok {
		r1 = rf(column, value...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Transaction_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type Transaction_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - column interface{}
//   - value ...interface{}
func (_e *Transaction_Expecter) Update(column interface{}, value ...interface{}) *Transaction_Update_Call {
	return &Transaction_Update_Call{Call: _e.mock.On("Update",
		append([]interface{}{column}, value...)...)}
}

func (_c *Transaction_Update_Call) Run(run func(column interface{}, value ...interface{})) *Transaction_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_Update_Call) Return(_a0 *orm.Result, _a1 error) *Transaction_Update_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Transaction_Update_Call) RunAndReturn(run func(interface{}, ...interface{}) (*orm.Result, error)) *Transaction_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateOrCreate provides a mock function with given fields: dest, attributes, values
func (_m *Transaction) UpdateOrCreate(dest interface{}, attributes interface{}, values interface{}) error {
	ret := _m.Called(dest, attributes, values)

	if len(ret) == 0 {
		panic("no return value specified for UpdateOrCreate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, interface{}) error); ok {
		r0 = rf(dest, attributes, values)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transaction_UpdateOrCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateOrCreate'
type Transaction_UpdateOrCreate_Call struct {
	*mock.Call
}

// UpdateOrCreate is a helper method to define mock.On call
//   - dest interface{}
//   - attributes interface{}
//   - values interface{}
func (_e *Transaction_Expecter) UpdateOrCreate(dest interface{}, attributes interface{}, values interface{}) *Transaction_UpdateOrCreate_Call {
	return &Transaction_UpdateOrCreate_Call{Call: _e.mock.On("UpdateOrCreate", dest, attributes, values)}
}

func (_c *Transaction_UpdateOrCreate_Call) Run(run func(dest interface{}, attributes interface{}, values interface{})) *Transaction_UpdateOrCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(interface{}), args[1].(interface{}), args[2].(interface{}))
	})
	return _c
}

func (_c *Transaction_UpdateOrCreate_Call) Return(_a0 error) *Transaction_UpdateOrCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_UpdateOrCreate_Call) RunAndReturn(run func(interface{}, interface{}, interface{}) error) *Transaction_UpdateOrCreate_Call {
	_c.Call.Return(run)
	return _c
}

// Where provides a mock function with given fields: query, args
func (_m *Transaction) Where(query interface{}, args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Where")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(interface{}, ...interface{}) orm.Query); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_Where_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Where'
type Transaction_Where_Call struct {
	*mock.Call
}

// Where is a helper method to define mock.On call
//   - query interface{}
//   - args ...interface{}
func (_e *Transaction_Expecter) Where(query interface{}, args ...interface{}) *Transaction_Where_Call {
	return &Transaction_Where_Call{Call: _e.mock.On("Where",
		append([]interface{}{query}, args...)...)}
}

func (_c *Transaction_Where_Call) Run(run func(query interface{}, args ...interface{})) *Transaction_Where_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_Where_Call) Return(_a0 orm.Query) *Transaction_Where_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_Where_Call) RunAndReturn(run func(interface{}, ...interface{}) orm.Query) *Transaction_Where_Call {
	_c.Call.Return(run)
	return _c
}

// WhereBetween provides a mock function with given fields: column, x, y
func (_m *Transaction) WhereBetween(column string, x interface{}, y interface{}) orm.Query {
	ret := _m.Called(column, x, y)

	if len(ret) == 0 {
		panic("no return value specified for WhereBetween")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}) orm.Query); ok {
		r0 = rf(column, x, y)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_WhereBetween_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereBetween'
type Transaction_WhereBetween_Call struct {
	*mock.Call
}

// WhereBetween is a helper method to define mock.On call
//   - column string
//   - x interface{}
//   - y interface{}
func (_e *Transaction_Expecter) WhereBetween(column interface{}, x interface{}, y interface{}) *Transaction_WhereBetween_Call {
	return &Transaction_WhereBetween_Call{Call: _e.mock.On("WhereBetween", column, x, y)}
}

func (_c *Transaction_WhereBetween_Call) Run(run func(column string, x interface{}, y interface{})) *Transaction_WhereBetween_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(interface{}))
	})
	return _c
}

func (_c *Transaction_WhereBetween_Call) Return(_a0 orm.Query) *Transaction_WhereBetween_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_WhereBetween_Call) RunAndReturn(run func(string, interface{}, interface{}) orm.Query) *Transaction_WhereBetween_Call {
	_c.Call.Return(run)
	return _c
}

// WhereIn provides a mock function with given fields: column, values
func (_m *Transaction) WhereIn(column string, values []interface{}) orm.Query {
	ret := _m.Called(column, values)

	if len(ret) == 0 {
		panic("no return value specified for WhereIn")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, []interface{}) orm.Query); ok {
		r0 = rf(column, values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_WhereIn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereIn'
type Transaction_WhereIn_Call struct {
	*mock.Call
}

// WhereIn is a helper method to define mock.On call
//   - column string
//   - values []interface{}
func (_e *Transaction_Expecter) WhereIn(column interface{}, values interface{}) *Transaction_WhereIn_Call {
	return &Transaction_WhereIn_Call{Call: _e.mock.On("WhereIn", column, values)}
}

func (_c *Transaction_WhereIn_Call) Run(run func(column string, values []interface{})) *Transaction_WhereIn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]interface{}))
	})
	return _c
}

func (_c *Transaction_WhereIn_Call) Return(_a0 orm.Query) *Transaction_WhereIn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_WhereIn_Call) RunAndReturn(run func(string, []interface{}) orm.Query) *Transaction_WhereIn_Call {
	_c.Call.Return(run)
	return _c
}

// WhereNotBetween provides a mock function with given fields: column, x, y
func (_m *Transaction) WhereNotBetween(column string, x interface{}, y interface{}) orm.Query {
	ret := _m.Called(column, x, y)

	if len(ret) == 0 {
		panic("no return value specified for WhereNotBetween")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}) orm.Query); ok {
		r0 = rf(column, x, y)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_WhereNotBetween_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereNotBetween'
type Transaction_WhereNotBetween_Call struct {
	*mock.Call
}

// WhereNotBetween is a helper method to define mock.On call
//   - column string
//   - x interface{}
//   - y interface{}
func (_e *Transaction_Expecter) WhereNotBetween(column interface{}, x interface{}, y interface{}) *Transaction_WhereNotBetween_Call {
	return &Transaction_WhereNotBetween_Call{Call: _e.mock.On("WhereNotBetween", column, x, y)}
}

func (_c *Transaction_WhereNotBetween_Call) Run(run func(column string, x interface{}, y interface{})) *Transaction_WhereNotBetween_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(interface{}), args[2].(interface{}))
	})
	return _c
}

func (_c *Transaction_WhereNotBetween_Call) Return(_a0 orm.Query) *Transaction_WhereNotBetween_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_WhereNotBetween_Call) RunAndReturn(run func(string, interface{}, interface{}) orm.Query) *Transaction_WhereNotBetween_Call {
	_c.Call.Return(run)
	return _c
}

// WhereNotIn provides a mock function with given fields: column, values
func (_m *Transaction) WhereNotIn(column string, values []interface{}) orm.Query {
	ret := _m.Called(column, values)

	if len(ret) == 0 {
		panic("no return value specified for WhereNotIn")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, []interface{}) orm.Query); ok {
		r0 = rf(column, values)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_WhereNotIn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereNotIn'
type Transaction_WhereNotIn_Call struct {
	*mock.Call
}

// WhereNotIn is a helper method to define mock.On call
//   - column string
//   - values []interface{}
func (_e *Transaction_Expecter) WhereNotIn(column interface{}, values interface{}) *Transaction_WhereNotIn_Call {
	return &Transaction_WhereNotIn_Call{Call: _e.mock.On("WhereNotIn", column, values)}
}

func (_c *Transaction_WhereNotIn_Call) Run(run func(column string, values []interface{})) *Transaction_WhereNotIn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].([]interface{}))
	})
	return _c
}

func (_c *Transaction_WhereNotIn_Call) Return(_a0 orm.Query) *Transaction_WhereNotIn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_WhereNotIn_Call) RunAndReturn(run func(string, []interface{}) orm.Query) *Transaction_WhereNotIn_Call {
	_c.Call.Return(run)
	return _c
}

// WhereNotNull provides a mock function with given fields: column
func (_m *Transaction) WhereNotNull(column string) orm.Query {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for WhereNotNull")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string) orm.Query); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_WhereNotNull_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereNotNull'
type Transaction_WhereNotNull_Call struct {
	*mock.Call
}

// WhereNotNull is a helper method to define mock.On call
//   - column string
func (_e *Transaction_Expecter) WhereNotNull(column interface{}) *Transaction_WhereNotNull_Call {
	return &Transaction_WhereNotNull_Call{Call: _e.mock.On("WhereNotNull", column)}
}

func (_c *Transaction_WhereNotNull_Call) Run(run func(column string)) *Transaction_WhereNotNull_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Transaction_WhereNotNull_Call) Return(_a0 orm.Query) *Transaction_WhereNotNull_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_WhereNotNull_Call) RunAndReturn(run func(string) orm.Query) *Transaction_WhereNotNull_Call {
	_c.Call.Return(run)
	return _c
}

// WhereNull provides a mock function with given fields: column
func (_m *Transaction) WhereNull(column string) orm.Query {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for WhereNull")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string) orm.Query); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_WhereNull_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WhereNull'
type Transaction_WhereNull_Call struct {
	*mock.Call
}

// WhereNull is a helper method to define mock.On call
//   - column string
func (_e *Transaction_Expecter) WhereNull(column interface{}) *Transaction_WhereNull_Call {
	return &Transaction_WhereNull_Call{Call: _e.mock.On("WhereNull", column)}
}

func (_c *Transaction_WhereNull_Call) Run(run func(column string)) *Transaction_WhereNull_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *Transaction_WhereNull_Call) Return(_a0 orm.Query) *Transaction_WhereNull_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_WhereNull_Call) RunAndReturn(run func(string) orm.Query) *Transaction_WhereNull_Call {
	_c.Call.Return(run)
	return _c
}

// With provides a mock function with given fields: query, args
func (_m *Transaction) With(query string, args ...interface{}) orm.Query {
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for With")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func(string, ...interface{}) orm.Query); ok {
		r0 = rf(query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_With_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'With'
type Transaction_With_Call struct {
	*mock.Call
}

// With is a helper method to define mock.On call
//   - query string
//   - args ...interface{}
func (_e *Transaction_Expecter) With(query interface{}, args ...interface{}) *Transaction_With_Call {
	return &Transaction_With_Call{Call: _e.mock.On("With",
		append([]interface{}{query}, args...)...)}
}

func (_c *Transaction_With_Call) Run(run func(query string, args ...interface{})) *Transaction_With_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *Transaction_With_Call) Return(_a0 orm.Query) *Transaction_With_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_With_Call) RunAndReturn(run func(string, ...interface{}) orm.Query) *Transaction_With_Call {
	_c.Call.Return(run)
	return _c
}

// WithTrashed provides a mock function with given fields:
func (_m *Transaction) WithTrashed() orm.Query {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for WithTrashed")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func() orm.Query); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_WithTrashed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithTrashed'
type Transaction_WithTrashed_Call struct {
	*mock.Call
}

// WithTrashed is a helper method to define mock.On call
func (_e *Transaction_Expecter) WithTrashed() *Transaction_WithTrashed_Call {
	return &Transaction_WithTrashed_Call{Call: _e.mock.On("WithTrashed")}
}

func (_c *Transaction_WithTrashed_Call) Run(run func()) *Transaction_WithTrashed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Transaction_WithTrashed_Call) Return(_a0 orm.Query) *Transaction_WithTrashed_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_WithTrashed_Call) RunAndReturn(run func() orm.Query) *Transaction_WithTrashed_Call {
	_c.Call.Return(run)
	return _c
}

// WithoutEvents provides a mock function with given fields:
func (_m *Transaction) WithoutEvents() orm.Query {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for WithoutEvents")
	}

	var r0 orm.Query
	if rf, ok := ret.Get(0).(func() orm.Query); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(orm.Query)
		}
	}

	return r0
}

// Transaction_WithoutEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithoutEvents'
type Transaction_WithoutEvents_Call struct {
	*mock.Call
}

// WithoutEvents is a helper method to define mock.On call
func (_e *Transaction_Expecter) WithoutEvents() *Transaction_WithoutEvents_Call {
	return &Transaction_WithoutEvents_Call{Call: _e.mock.On("WithoutEvents")}
}

func (_c *Transaction_WithoutEvents_Call) Run(run func()) *Transaction_WithoutEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Transaction_WithoutEvents_Call) Return(_a0 orm.Query) *Transaction_WithoutEvents_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Transaction_WithoutEvents_Call) RunAndReturn(run func() orm.Query) *Transaction_WithoutEvents_Call {
	_c.Call.Return(run)
	return _c
}

// NewTransaction creates a new instance of Transaction. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransaction(t interface {
	mock.TestingT
	Cleanup(func())
}) *Transaction {
	mock := &Transaction{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
